#### Golang 官方文档

官方变成指南

网址：http://tour.studygolang.com/welcome/1

中文标准库：https://studygolang.com/pkgdoc

在线工具：https://tool.lu/



##### Golang  的学习方向

1.区块链研发工程师

2.Go服务端、游戏工程师

3.分布式云计算

###### 什么是区块链

​	分布式账本技术，核心思想是去中心化，人人都可以去参与数据库的记录，金融，虚拟货币

##### 什么是程序

程序：就是完成某个功能的指令集合

##### Go语言的特点

1. Go = C + Python

2. 从C语言中继承了很多理念，表达式语法，控制结构，基础数据类型，调用参数传值，指针等等

3. 保留了和C语言一样的额编译方式以及弱化的指针

4. 引入包的概念，用于组织程序结构，Go语言的一个文件都要归属一个包，不能单独存在（）

5. 垃圾回收机制，内存自动回收，无需开发人员管理

6. **天然并发**

   **a。从语言层面支持并发**

   **b。轻量级线程，可实现大并发处理，高效利用多核**

   **c。基于CPS并发模型**

7. 静态语言的安全和性能

8. 动态语言开发维护的高效率

##### Go语言开发的环境搭建

1. 安装和配置SDK

###### 什么是SDK

SDK：软件开发工具包，里面包含各种工具包，编译器以及API

##### golang 中文地址

https://studygolang.com/dl

#### 项目目录结构

```go
package main

import "fmt"

func main(){
	fmt.Println("hello,world!")
}
```



1. go文件后缀尸 .go

2. 在 go 中 ，每个文件都归属于一个包

3. import “fmt”

   表示引入一个包，包名：fmt ，引入该包后 就可以使用 fmt 包的函数如：fmtPrintln

4. main 是一个主函数  就是我们程序的入口

### go程序执行

1. 进入到指定文件
2. go build  会编译成一个 .exe 程序 
3. 执行该  .exe 程序    
4. 也可以通过 go run 直接运行 
5. go build  => 先编译成一个可执行的文件，然后再去手动执行一次可执行文件
6. go run  => 它是直接编译后 无需手动执行，它会自动帮你执行可执行文件

##### go build 与 go run 的区别

1. go build 编译成一个可执行文件，我们编译后的可执行文件，可以在其他机器上运行，无需go的开发环境
2. go run 在另外一台机器上执行，同样也需要go开发环境
3. 在编译时，编译器会将你写的源代码和程序依赖库包含在可执行文件中，所以可执行文件变大了很多

##### 什么是编译

1. 有了go源文件，通过编译器将其编译成机器可以识别的二进制码文件
2. 在源文件目录下，通过go build 对 .go 文件进行编译，可以生成指定可执行文件名，在Windows 下 必须是.exe后缀..

##### 什么是运行

1. 直接运行生成的可执行Go程序 => hello.**exe**
2. 通过运行工具  go run 对源代码文件进行-运行

## Go 程序开发注意事项（重点）

1. go 源文件以 go 为扩展名

2. go 应用程序的执行入口是 main() 函数

3. 在 go 中，函数和方法 看似很像，实则他们有着区别

4. go 方法有一条一条语句构成的，每个语句 后面 无需加分号，go语言会在每行后自动加分号，体现出 Golang 的简洁性

5. Go 编译器 是一行一行进行编译的，我们一行就写一条语句，不能把多条语句写在同一行，否则会报错

6. go 语言定义的 变量 和  import 的包 没有被用到(未被使用)，代码不能编译通过

   

##### go 语言转义字符

常用 转义符 

1. \t   表格
2. \n  换行
3.  \   转义
4. \r  回车   表示从当前行 最前面 开始输入覆盖以前的内容



#### DOS常用命令

##### 什么是DOS

​	简介：磁盘操作系统----Windows 的目录结构

#####  DOS的操作原理

程序员通过操作 cmd 控制控制台 发送指令 到 DOS操作系统 ，然后DOS系统解析我们发送的指令，Windows 做出相应的 动作

常用

##### DOS对目录的操作

dir：查看当前的所有目录的指令

cd /d f:   ：代表是从当前目录切换到 F 盘，cd /d "要切换的盘符"：

cd d:\project_01  ：代表切换到 D 盘的 project_01 目录下

cd .. ：代表回到上一级目录

cd \ ：回到最顶级目录  即 根目录

md ： 新建目录，创建多个目录  使用 空格 隔开  md "目录名字”

rd ： 删除空目录，不能删除有内容的目录 rd “目录名字“

rd /q/s ： 删除目录 ， 可以删除有内容的目录 ，不会询问

rd /s ：带询问的 删除目录

##### DOS对文件的操作

echo 我的第一个文件 > my.txt  ： 代表在当前目录下 创建一个 内容为”我的第一个文件“ 的txt文件

copy abc.txt d:\test200 ：将当前的文件夹下 abc.txt 文件拷贝到 d:\test200 目录下，也可以重新命名拷贝过来的文件名字

move abc.txt f:\  ： 将当前文件夹下的 abc.txt 文件 剪切到 F 目录下 f:\”后面跟上名字”也可以将剪切过来的文件重新命名

del abc.txt ： 删除 abc.txt  文件，如果是 *.txt  代表删除当前目录下的 所有 txt 文件

##### 其他指令

cls：清屏

exit ：退出 DOS

## 变量

1. 为什么需要变量

   一个程序就是一个世界，变量是程序的基本组成

2. 变量介绍

   变量相当于在内存中一个数据存储空间便是，可以通过变量名访问到对应的变量值

   变量申明/定义

   变量赋值

   使用

3. 变量的案例

   ```go
   package main
   
   import "fmt"
   
   func main()  {
   	// 定义变量
   	var i int
   	
   	// 给变量赋值
   	i = 20
   
   	// 使用变量
   	fmt.Println("i=",i)
   }
   ```

4. 变量使用 注意事项

   变量表内存中的一个存储空间

   在存储空间中，变量自己的 变量名 和 变量值和类型

   **指定变量类型，若声明后不赋值，将会使用默认值**

   int 的默认值 是 0

   **根据值自动判断变量类型(类型推导)**

   省略 var   name:="Jony" === var name String = "Jony"

5. 多变量声明

   ```go
   package main
   
   import "fmt"
   
   func main()  {
   	// 一次性定义多个变量
   	// var n1,n2,n3 int;
   
   	// fmt.Println(n1,n2,n3)
   
   	// 第二种声明方式
   	// var n1,n2,n3 = 100,"Jony",000
   
   	// fmt.Println(n1,n2,n3)
   
   		// 第三种声明方式  类型推导
   	n1,n2,n3 := 100,"Jony",000
   
   	fmt.Println(n1,n2,n3)
   		
   }
   ```

   定义全局变量

   ```go
   package main
   
   import "fmt"
   
   // 定义全局变量 1
   var aa = 100
   var bb = 200
   var cc = 300
   
   // 定义全局变量 2
   var (
   	name = "Jony"
   	age = 19
   	tz = 110
   )
   
   func main()  {
   
   
   	fmt.Println(name,age,tz)
   
   	fmt.Println(aa,bb,cc)
   		
   }
   ```

6. 该区域的数据值可以在同一类型范围内不断变化

7. 变量在同一个 作用域 内不能重名

8. 变量 = 变量名 + 值 + 数据类型

9. Golang 的变量如果没有赋初始值，编译器会使用默认值，比如 int 为0，string 为 空字符串，小数 为 0

### 基本语法

  var 变量名 数据类型

如何查看一个 数据的类型

​	fmt.Printf(" %T ", "要查看的变量名" )

如何查看变量的占用字节大小



### 变量的数据类型

#### 基本数据类型

1. 数值型

   整数类型：int8  int16  int32  int64  uint  uint8....

   浮点类型：float32  float64

2. 字符型：使用 byte 保存单个字母字符

3. 布尔型：true  false

4. 字符串

   

#### 派生/复杂数据类型

1. 指针
2. 数据
3. 结构体
4. 管道
5. 函数
6. 切片
7. 接口
8. map

###### 数据类型详解

1. 整数类型

   简单来说就是用来存放整数的  如 ： 1 100  100 5556

2. 浮点类型(小数类型)

   浮点类型的分类，float32 是单精度，float64 是双精度

   float64  精度更加准确

   默认是 float64

   科学 计数法 ：num :=5.1234e2  => 代表5.1234 * 10的2次方  512.34

   ​			num :=5.1234E-2  => 代表 5.1234 / 10的2次方  0.051234

3. 字符类型

   Go 的字符串是由 字节 组成

   Go 语言的字符使用 UTF-8编码

4. 布尔类型：bool

   值只能是 true 或 false
   
   一般用于 if  条件判断语句  或者  for 循环 语句
   
5. 字符串类型

   字符串就是 一串 固定长度的字符连接起来的祖字符序列

   

   #### 基本数据类型转换

   1. Golang  中数据类型不能自动转换，需要显示转换

      var num float32 = 100

      var num2 float64 = float64(num)

   2. 被转换的是变量存储的类型，变量本身的数据类型没有发生变化

   ##### 基本数据类型转 String

   1. fmt.Sprintf("需要转换的变量")  :会返回转换后的字符串
   2. strconv.FormatInt("需要转换的成String的变量"，"需要转换成多少进制")
   
   ##### String转基本数据类型
   
   1. strconv 包的函数
   
   2. 将String 类型转成基本数据类型时，**要确保 string 类型能够转成有效的数据**，比如将 123 转 整数  是ok的，但是将 hello 转成一个 整数，Golang 直接将其转成 0
   
      

## 指针

#### 基本介绍

1. 基本数据类型，变量存的就是值，也叫值类型

2. 获取变量的 地址 ：var int num = 10  ,  获取 num 的地址：&num

3. **指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值**

   **比如：var prt *int = &i**

4. 获取指针类型所指向的值，使用" * "，比如：var ptr *int ,使用 ***ptr** 获取 P指向的值

##### 总结

 	**基本数据类型，变量存的是值，也就是说 变量在 内存空间里面 ，变量名指向这个变量的值，这个 变量 有一个 内存空间，是由 字母和数字构成，比如：0100xc1001，查看变量的 内存地址 使用 " & " 加变量名**



​	**指针类型，存放的是  变量的  内存地址，在内存空间里面，指针类型指向的是 这个变量的内存地址**

​		**比如：普通变量**

​					**var num int = 10**

​					**那么这个 num  在内存空间指向的是  10这个 变量，但是他有一个内存地址。**

​			**指针变量**

​					**var prt *int = &num**

​					**这个 prt 存放的是  num 的内存地址，prt 自己也在内存空间开辟了一个新的内存块，也有一个自己的 内存地址，但是它会有一个自己的 内存地址**

​	`prt 取自己存放的  内存地址的 值 ： *ptr`

​	`num 取自己的内存地址 ： &num`



​		**普通变量 和 指针变量的 区别**

​		**普通变量存放的是 值**

​		**指针变量存放的是  内存地址**

**指针类型也有 数据类型**

##### 指针类型细节说明

1. 值类型，都对应的指针类型，形式为：数据类型，

   比如：int 的对应指针就是  *int

2. 值类型包括：基本数据类型 int 系列，数组和结构体



##### 值类型和引用类型

1. 值类型：基本数据类型
2. 引用类型：指针，slice切片，map，管道chan，interface接口，.....

###### 值类型和引用类型特点

1. 值类型：变量直接存储值，内存通常在 **栈** 中分配
2. 引用类型：变量存储的是一个地址，通常放在 **堆** 区，这个地址对应的空间才真正的存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就会成为一个垃圾，由GC来回收，称为“垃圾回收机制”

## 标识符的命名规范

1. 关键字不能用 ，一共25个
2. 不能以 _  单独的命名
3. 命名中不能带有空格
4. Golang 中区分大小写d

## 运算符

简单介绍：运算符是一种特殊的符号，用以表示数据的运算、赋值、比较

1. 算数运算符
2. 赋值运算符
3. 比较运算符
4. 逻辑运算符
5. 位运算符
6. 其他运算符

**除法：如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分******，如果我们希望保留小数部分，则需要有浮点数参与运算****

**取磨/取余：公式 = >  a % b =  a - a / b * b，本质就是看 a 的符号的是正负数，正数结果就是正，负数结果 就是 负**

细节：Golang 中，+ +  和  - -  只能独立使用，

​		比如：var i int = b ++   这是错误的

##### 关系运算符/比较运算符

1. 关系运算符最终的结果都是 bool 型，true 或 false
2. 关系运算符经常用在 if 结构的条件中，或 循环结构条件中

##### 逻辑运算符

1. 连接连接多个条件（一般都是关系表达式），最终的结果也是一个 bool 值

&& ：一假则假

||  ：一真则真

！ ：  取反

##### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量



## 键盘输入语句

在编程过程中，需要接受用户输入的数据，就可以使用键盘输入语句来获取

语法：fmt.Scanln() 或 fmt.Scanf()

当程序执行到 fmt.Scanln() 时，程序会停止，等待用户输入，并且回车

## 进制

对于整数，有四种表示方式

1. 二进制，满 2 进 1
2. 十进制，满 10 进 1
3. 八进制，满8 进 1，以数字 0 开头
4. 十六进制，0-9及A-F，以0或者X开头表示，不区分大小写

##### 二进制 转换成 十进制

规则：从最低位开始（右边的），将每个位上的数提取出来，乘 2 的（位数 - 1）次方，然后求和

​		案例：

将：1011 转成十进制

1011 = 1 * 1 + 1 * 2 + 0 * 2 * 2 + 1 * 2 * 2 * 2 = 1 + 2 + 0 + 8 = 11



##### 八进制 转换成 十进制

规则：从最低位开始（右边的），将每个位上的数提取出来，乘 8 的（位数 - 1）次方，然后求和

​		案例：

将：0123 转成十进制

0123 = 3 * 1 + 2 * 8 + 1 * 8 * 8 + 0 * 8 * 8 * 8 = 3 + 16 + 64 + 0 = 83



##### 十六进制 转换成 十进制

规则：从最低位开始（右边的），将每个位上的数提取出来，乘 16 的（位数 - 1）次方，然后求和

​		案例：

将：0x34A 转成十进制

0x34A = 842

在十六进制中，A 代表 10

顺序表：1 2  3 4 5 6 7 8 9 a b c d e f 

#### 十进制 转换成 二进制

规则：将得到的数 不断除以2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制

​		案例：

将：56 转成二进制 =>  111000



#### 十进制 转换成 八进制

规则：将得到的数 不断除以8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制

​		案例：

将：156 转成二进制 => 234



#### 十进制 转换成 十六进制

规则：将得到的数 不断除以16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制

## 位运算

 						在计算机的内部，运行各种运算时，都是以二进制来运行

##### 原码、反码、补码

​		对于有符号的数而言

1. 二进制的最高位是符号位：0表示正数，1表示负数，首位代表符号位

   1===> [0000 0001]

   -1===> [1000 0001] 

2. 正数的 原码 反码 补码 都是一样的

3. 负数的反码 = 它的原码符号位不变，其它位 取反 （0-1，1-0）

   1===> 原码 [0000 0001]  反码[0000 0001]  补码[0000 0001]

   -1===> 原码 [1000 0001]  反码[1111 1110] 补码[1111 1111]

4. 负数的补码 = 它的反码 + 1

5. 0的反码，补码都是 0 

6. 在计算机 运算的 时候，都是以补码的方式来运算的



##### 3个位运算

1. 按位 & ：两位全为1，结果为1，否则为0

2. 按位 | ：两位有一位为1，结果为1，否则为0

3. 按位 ^ ：两位一个为0，一个为1，结果为1，否则为0

   ​	案例

   2&3 

   2 === 补码[0000 0010]

   3 === 补码[0000 0011]

   ​					0000 0010  => 2

   2|3

   2 === 补码[0000 0010]

   3 === 补码[0000 0011]

   ​					0000 0011  => 3

   2^3

   2 === 补码[0000 0010]

   3 === 补码[0000 0011]

   ​					0000 0001  => 1

   -2^2

   -2 === 原码[1000 0010] => 反码 [1111 1101] => 补码[1111 1110]

   ​				   [1111 1110]

   2 === 补码[0000 0010]

   ​					1111 1100  补码==>反码[1111 1011]==> 原码[1000 0100] === -4

##### 2个移位运算

1. 右移运算符 >> ：低位溢出，符号位不变，并用符号位补溢出的高位

2. 左移运算符 << ：符号位不变，低位补 0

   ​	案例

   a:=1 >> 2  0000 0001=> 0000 0000 = 0

   b:=1 << 2  0000 0001 => 0000 0100 => 4

## 程序流程控制

在程序中，程序运行的流程控制决定程序是如何执行的

流程控制语句

1. 顺序控制
2. 分支控制
3. 循环控制



##### 顺序控制

​	程序从上往下 逐行 执行 ，中间没有任何判断和跳转

​	Golang 中定义变量时采用合法的前向引用

##### 分支控制

​	让程序有选择的执行，分支控制有三种

1. 单分支

   if 条件表达式 {

   ​		执行代码块

   }

   说明：当条件表达式 为 true时，就会执行 { } 中的代码

   细节：在 if 中 ，条件判断语句里允许声明变量，这个变量的作用域只能在该条件逻辑块内，其他地方不起作用  ===>  if age: = 20; age > 18 { ..... }

2. 双分支

3. 多分支